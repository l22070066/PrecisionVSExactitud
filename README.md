PrecisionYExactitud:
El programa inicia declarando las variables que se van a utilizar. Esto incluye el Scanner que se utilizará para leer los datos que el usuario ingresará. También incluye el arreglo de números para calcular la precisión y exactitud. Después de esto, le pedimos al usuario que ingrese el valor real, con el que compararemos los valores dados por el usuario. Estos datos se reciben con un for loop, la cual le asigna un valor a cada espacio dentro del arreglo. Después de esto, ya tenemos que verificar la exactitud. La exactitud se logra calcular mediante otro for loop, la cual compara los valores del arreglo con el valor real. Antes de iniciar la for loop, se declara un booleano con valor falso, cuando se chequeen todos los valores y se cumpla la condición de que todos estén dentro del rango, entonces se declara como verdadero. Verifica que cada valor esté dentro de 0.1 unidades. En dado caso que no se cumpla esto, se terminará la for loop, y el valor del booleano sea falso. Después hay un if que verifica que el booleano sea verdadero, en dado caso que dirá que el arreglo de datos es preciso. Si es falso, entonces se imprimirá que es impreciso. La precisión se calcula de manera similar, en que se utiliza el mismo sistema de fors, solo que esta vez tenemos que incluir otro for, para comparar cada valor del arreglo. Si llega a haber un valor que no esté dentro de 0.1 unidades, entonces se termina la for loop y tenemos que no son precisos. Pero si se cumplen todas las condiciones, entonces sí son precisos.

PuntoFijo:
El programa inicia con la importación de una librería la cual permite que el usuario ingrese una función a través de texto. Con esto continuamos a declarar las variables que se utilizarán. Ya con estos definidos, le pedimos al usuario que ingrese su función. Esta se convierte a algo que podemos calcular con la librería, solo le tenemos que indicar cuál va a ser el variable en la ecuación y su valor. Después le pedimos al usuario la función g(x). Con ambas funciones definidas, ahora le pediremos al usuario el primer valor y el error deseado. Con esto podemos continuar al método Punto Fijo. Ahora empezaremos con un ciclo for, el cual se utiliza para las iteraciones del método. Dentro del ciclo, el primer ciclo será diferente al resto, ya que no se puede calcular el error en la primera iteración. Con la segunda función g(x), podemos reemplazar el valor de x dado por el usuario y encontrar la posición estimada de la raíz. En la primera iteración. Esto será lo único que se hace. Después de la primera iteración, se hará casi lo mismo, salvo por la declaración de otro variable y la igualación a la raíz anterior, con esto, se puede calcular el error utilizando la fórmula (x1-x0)/x1. Con este valor del error, también tenemos una condición, la cual checa que el error calculado por la función sea menor que el error dado por el usuario. Cuando se cumple esta condición, tenemos que el programa imprimirá los datos de la ejecución, como el número de iteraciones y el error, junto con la raíz aproximada de f(x).

Jacobi:
El programa inicia declarando 12 variables, de los cuales, 5 son matrices y 7 son variables regulares. Todos son doubles. Las matrices se utilizarán en base al procedimiento requerido del Método de Jacobi. Y por último, se declara un variable del tipo int para contar las iteraciones. Para iniciar, se utilizarán dos ciclos for, los cuales servirán para establecer los valores de la matriz original. Mientras el usuario ingresa los valores, aprovechamos el uso de este for y el ingreso de los datos para que establecer las siguientes matrices que se usarán. Estas incluyen a la matriz diagonal, la cual contiene solo los valores de la diagonal, pero aparte de esto, son los recíprocos, dado que se requiere para el método. También se aprovecha para llenar la matriz superior e inferior negativas. Ya con estas 3 matrices llenas, continuamos a establecer la matriz de valores iniciales y la matriz de la ecuación. La matriz de los valores iniciales la creamos usando los valores de la matriz diagonal, multiplicada por la solución a las ecuaciones originales. Le aplicamos estos valores a los variables doubles declarados antes, específicamente xV, yV y zV, los cuales representan los valores viejos ya calculados en el método. La matriz de la ecuación se establece a través de la multiplicación de la matriz diagonal con la matriz inferior y superior negativa. Con todas nuestras matrices ya declaradas, podemos continuar a la aplicación del método. Ahora ya empezamos a aproximar a las soluciones de la ecuación. Primero se pedirá el margen de error deseado. La primera iteración no se hará nada, dado que los primeros valores se calcularon previamente. Los valores se calcularán mediante el uso de la matriz de ecuación y el valor viejo de los variables (xV, yV, zV). Igualando estos a xN, yN y zN. Después existe una condición para chequear que el margen de error. Cuando se cumpla, un booleano se hará verdadero, después de esto continuamos a igualar los valores de xV, yV y zV a los recién calculados xN, yN y zN. En dado caso que el booleano sea verdadero, entonces se terminará el ciclo y se le presentará los valores aproximados al usuario, junto con las iteraciones que se requirieron.

MetodoSimpson:
El programa inicia importando la librería utilizada anteriormente en el método del punto fijo. Ya con esta librería importada, empezamos con la clase, declarando un Scanner para leer datos. Después de esto, creamos el método metodoSimpson(), en el cual se ejecutará el código. Dentro del método, declaramos nuestro variable func, que es aquello de la librería y será lo que representan nuestra función. Después declaramos 3 doubles, a, b y x, de los cuales, a y b son el límite inferior y superior respectivamente. El variable x se utilizará para calcular el valor de la función, es decir, solucionar para x. Y por último, declararemos el int n, el cual se usará para los intervalos del método. Con los variables declarados, le pedimos al usuario que ingrese su función, la cual se convertirá a una ecuación que Java puede calcular, a través de la librería. Con esto ya establecido, le pedimos al usuario el valor del límite inferior y superior, más aparte los intervalos deseados. En dado caso que el usuario ingrese un número de intervalos impar, se le arrojará un error, indicándole que deben ser pares. Después calculamos h, declaramos dos doubles, sumaImpar y sumaPar, e igualamos x al valor de a, o el límite inferior. Con esto abrimos un ciclo for, en el cual calcularemos los valores de los intervalos, sean par o impar. En caso que sean par, calculamos su valor y lo agregamos al variable de sumaPar, en el caso contrario, se agregará a sumaImpar. Esto se repetirá dependiendo de el número de intervalos. Y por último, calcularemos el valor de la función en los límites del intervalo, ya que no se calcularon en el ciclo for. Con esto, tenemos todos los datos necesarios para hacer nuestra aproximación. Imprimimos la línea en la cual indica cuál es la aproximación y se calcula el área mediante la fórmula de Simpson, en este caso dividiendo h entre 3 multiplicándolo por el valor del límite inferior del intervalo, sumándole 4 veces la sumaImpar, más 2 veces la suma par, más el valor del límite superior del intervalo.
